#include <GLWindow.h>
#include <GLCamera.h>
#include <GLRenderer.h>
#include <GLUtils.h>
#include <GLObject.h>
#include <GLResource.h>

//Note : Use OpenGL >= 1.5
using namespace glm;

GLCamera3D       cam3d;
GLRenderer       render;
GLObjectImport   model;
GLImageManager     ImageMana;
GLTextureManager   TextureMana;

glm::vec3 pos = {10, 10, 10};
glm::vec3 dir = {0, -1, 0};
glm::vec3 up  = {0, 0, 1};

glm::vec3 pCursor;

glm::vec3 cur_new;
glm::vec3 cur_old;

bool bRotate;

vector<vec3> grid;


/*
    http://www.it.hiof.no/~borres/j3d/explain/light/p-materials.html

*/


//  ==== Light ====
float light_ambient []  = { 0.2f, 0.2f, 0.2f, 1.0f };
float light_diffuse []  = { 0.8f, 0.8f, 0.8f, 1.0f };
float light_specular[]  = { 0.5f, 0.5f, 0.5f, 1.0f };
vec4  light_position  =  { 10.0f, 10.0f, 10.0f, 0.0 };

//  ==== Material ====
float mat_ambient[] ={ 0.0f,0.0f,0.0f,1.0f };
float mat_diffuse[] ={ 0.5f,0.0f,0.0f,1.0f};
float mat_specular[] ={0.7f,0.6f,0.6f,1.0f };
float mat_shine =32.0f ;


//Yellow plastic
//float mat_ambient []={0.0f,0.0f,0.0f,1.0f };
//float mat_diffuse []={0.5f,0.5f,0.0f,1.0f };
//float mat_specular[] ={0.60f,0.60f,0.50f,1.0f };
//float mat_shine = 15.0f ;



//Emerald
//float mat_ambient [] ={ 0.0215f, 0.1745f, 0.0215f, 0.55f };
//float mat_diffuse [] ={0.07568f, 0.61424f, 0.07568f, 0.55f };
//float mat_specular[] ={0.633f, 0.727811f, 0.633f, 0.55f };
//float mat_shine = 76.8f;

GLfloat shinyness[] = { 0.0 };



GLfloat mat_diffuse1[] = { 1.0, 0.0, 0.0, 1.0 };


/*
    Other light and material settings don't have to be modified when lighting is turned off
    When a vertex is generated by a call to one of the glVertex* functions, a copy of each of 
    the current material properties is stored, along with the vertex coordinates
    Note that the normal vector for a vertex must be specified before glVertex* is called for that vertex.
    Remember that the normal vector should point out of the front face of the polygon


    When the fourth number, w, is zero, then the light is directional and the point (x,y,z) specifies the direction of the light
    On the other hand, if the fourth number, w, is non-zero, then the light is a point light
    The default position for all lights is (0,0,1,0), representing a directional light shining from the positive direction of the z-axis, 
    towards the negative direction of the z-axis.

    When lighting is enabled, the color vertex attribute that was specified with glColor family of functions is ignored. 
    This color by itself doesn’t provide enough information to determine the final color of a fragment.

    Instead of defining the color of each vertex, we must define a material definition that will be used to render an object.

    Ka ... ambient material
    Kd ... difusse material
    Ks ... specular material

    La ... ambient light
    Ld ... diffuse light
    Ls ... specular light
    sh ... shininess

    N  ... norlmal vector
    L  ... light vector (from the vertex postion to the light)
    V  ... view vector (from the vertex psotion to the eye)

    Id    = max(dot(N, L), 0.0);

    H     = normalize(V + L);
    NdotH = max(dot(N, H), 0.0);
    Is    = (sh + 2.0) * pow(NdotH, sh) / (2.0 * 3.14159265);

    fs    = Ka*La + Id*Kd*Ld + Is*Ks*Ls;
*/



GLuint vaoIDGrid;
GLuint vboIDGrid;


GLuint  vaoIDModel;
GLuint  vboIDModel;

GLuint  vaoIDModelTri;
GLuint  vboIDModelTri;

vector<glm::vec3> trig;
vector<glm::vec3> poly;
string dirModule;

float agl = 0.0;

DrawDataObject* drawDataObj = NULL;
vector<std::pair<GLuint, int>>      ListVaoIDTrig;
vector<const mtl_info*>             ListMtlTrig;

vector<std::pair<GLuint, int>>      ListVaoIDQuads;
vector<const mtl_info*>             ListMtlQuads;


vector<tagMaterialDrawInfo> MTLInfo;

void UseMTL(const tagMaterialDrawInfo* mtl)
{
    glEnable(GL_TEXTURE_2D);
    glBindTexture(GL_TEXTURE_2D, mtl->m_TextureID);
    glBindVertexArray(mtl->m_VaoID);
    if(mtl->m_Material->m_Ka) glMaterialfv(GL_FRONT_AND_BACK, GL_AMBIENT,  &mtl->m_Material->m_Ka->r);
    if(mtl->m_Material->m_Kd) glMaterialfv(GL_FRONT_AND_BACK, GL_DIFFUSE,  &mtl->m_Material->m_Kd->r);
    if(mtl->m_Material->m_Ks) glMaterialfv(GL_FRONT_AND_BACK, GL_SPECULAR, &mtl->m_Material->m_Ks->r);
    glMaterialf( GL_FRONT_AND_BACK, GL_SHININESS, mtl->m_Material->m_Ns );
}

void OnCreate(Window* win)
{
    cam3d.InitView(win->GetWidth(), win->GetHeight(), 0.1, 1000);
    cam3d.SetUpCamera(pos, dir, up);
    cam3d.SetFieldOfView(60.0f);
    cam3d.SetUpOrbitTarget(pos, vec3(0, 0, 0));
    cam3d.UpdateMatrix();

    string pathExe   = GetModuleCurrent();
    string pathModel = pathExe + "/models/";
    //model.LoadFromFile(pathExe + "/models/poly_tree.obj");
    //model.LoadFromFile(pathExe + "/models/low-poly-mill.obj");
    //model.LoadFromFile(pathExe + "/models/house.obj");
    //model.LoadFromFile(pathExe + "/models/low_poly_cars.obj");
    //model.LoadFromFile(pathExe + "/models/cube.obj");
    model.LoadFromFile(pathExe + "/models/13914_Taxi_v2_L1.obj");

    auto t_start = std::chrono::high_resolution_clock::now();
    drawDataObj = model.GetDrawDataObject();
    auto t_end = std::chrono::high_resolution_clock::now();

    double elapsed_time_ms = std::chrono::duration<double, std::milli>(t_end-t_start).count();
    cout << elapsed_time_ms << endl;

    grid = M3D_GetGrid(vec3(0, 0 ,0 ), 100 , 100 , 2, 5 );


    if (win->MakeContext())
    {
        glEnable(GL_DEPTH_TEST);
        glEnable(GL_MULTISAMPLE);
        glEnable(GL_NORMALIZE);
        glShadeModel(GL_SMOOTH);
        glEnable(GL_TEXTURE_2D);

        // Thiết lập LIGHT_0 đầu nó là ánh sáng global ha 
        // Nó chiếu sáng theo vị trí của viewer
        glEnable(GL_LIGHT0);
        glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER, GL_TRUE);
        glMateriali(GL_FRONT_AND_BACK, GL_SHININESS, 32);

        // Thiết lập màu của ánh sáng global
        float dim[] = { 0.95f, 0.95f, 0.95f, 1.f };
        glLightfv(GL_LIGHT0, GL_DIFFUSE, dim);
        glLightfv(GL_LIGHT0, GL_SPECULAR, dim);

        glGenVertexArrays(1, &vaoIDGrid);
        glGenBuffers(1, &vboIDGrid);

        glBindVertexArray(vaoIDGrid);
        glBindBuffer(GL_ARRAY_BUFFER, vboIDGrid); // Bind our Vertex Buffer Object
        glBufferData(GL_ARRAY_BUFFER, grid.size() *sizeof(vec3), &grid[0], GL_STATIC_DRAW);

        // Set up our vertex attributes pointer + Disable our Vertex Array Object
        //glVertexAttribPointer((GLuint)0, 3, GL_FLOAT, GL_FALSE, 2*sizeof(vec3), 0); 
        //glEnableVertexAttribArray(0);
        glEnableClientState(GL_VERTEX_ARRAY);
        glEnableClientState(GL_COLOR_ARRAY);
        glVertexPointer(3, GL_FLOAT, 2 * sizeof(vec3), 0); 
        glColorPointer(3, GL_FLOAT, 2 * sizeof(vec3), (void*)sizeof(vec3));
        glBindVertexArray(0); // Disable our Vertex Buffer Object

        //=====================================================

        //glGenVertexArrays(1, &vaoIDModel);
        //glBindVertexArray(vaoIDModel); // Bind our Vertex Array Object so we can use it

        //glGenBuffers(1, &vboIDModel); // Generate our Vertex Buffer Object
        //glBindBuffer(GL_ARRAY_BUFFER, vboIDModel); // Bind our Vertex Buffer Object
        //glBufferData(GL_ARRAY_BUFFER, poly.size() *sizeof(vec3), &poly[0], GL_STATIC_DRAW);

        //// Set up our vertex attributes pointer + Disable our Vertex Array Object
        ////glVertexAttribPointer((GLuint)0, 3, GL_FLOAT, GL_FALSE, sizeof(vec3), 0); 
        ////glEnableVertexAttribArray(0);
        //glEnableClientState(GL_VERTEX_ARRAY);
        //glEnableClientState(GL_COLOR_ARRAY);

        //glLightfv(GL_LIGHT0, GL_AMBIENT,  mat_ambient);
        //glLightfv(GL_LIGHT0, GL_DIFFUSE,  mat_diffuse);
        //glLightfv(GL_LIGHT0, GL_SPECULAR, mat_specular);

        //glVertexPointer(3, GL_FLOAT, 2*sizeof(vec3), 0);
        //glColorPointer(3, GL_FLOAT, 2*sizeof(vec3), (void* )sizeof(vec3));
        //glBindVertexArray(0); // Disable our Vertex Buffer Object

        ////=====================================================

        //glGenVertexArrays(1, &vaoIDModelTri);
        //glBindVertexArray(vaoIDModelTri); // Bind our Vertex Array Object so we can use it

        //glGenBuffers(1, &vboIDModelTri); // Generate our Vertex Buffer Object
        //glBindBuffer(GL_ARRAY_BUFFER, vboIDModelTri); // Bind our Vertex Buffer Object
        //glBufferData(GL_ARRAY_BUFFER, trig.size() *sizeof(vec3), &trig[0], GL_STATIC_DRAW);

        //// Set up our vertex attributes pointer + Disable our Vertex Array Object
        ////glVertexAttribPointer((GLuint)0, 3, GL_FLOAT, GL_FALSE, sizeof(vec3), 0); 
        ////glEnableVertexAttribArray(0);
        //glEnableClientState(GL_VERTEX_ARRAY);
        //glEnableClientState(GL_COLOR_ARRAY);
        //glVertexPointer(3, GL_FLOAT, sizeof(vec3), 0); 
        ////glColorPointer(3, GL_FLOAT, 2 * sizeof(vec3), (void*)sizeof(vec3));
        //glBindVertexArray(0); // Disable our Vertex Buffer Object

        for (int i = 0; i < drawDataObj->GetSize(); i++)
        {
            const tagFaceDrawInfo* mesh = (*drawDataObj)[i];
            // Trường hợp đầu tiên là với face là trig
            if (mesh->m_DataTrigs.size() > 0)
            {
                const mtl_info* mtl = mesh->m_UseMtlInfo;
    
                // Load toàn bộ texture vào bộ nhớ và giữ lại dữ liệu image
                string Kaname = mtl->m_name +"_Ka";
                string Kdname = mtl->m_name +"_Kd";
                string ksname = mtl->m_name +"_Ks";

                string fka = StandardFileName(mtl->m_map_Ka);
                string fkd = StandardFileName(mtl->m_map_Kd);
                string fks = StandardFileName(mtl->m_map_Ks);

                GLTexture* TexKa = !fka.empty() ? TextureMana.CreateTexture(Kaname, pathModel + fka) : NULL;
                GLTexture* TexKd = !fkd.empty() ? TextureMana.CreateTexture(Kdname, pathModel + fkd) : NULL;
                GLTexture* TexKs = !fks.empty() ? TextureMana.CreateTexture(ksname, pathModel + fks) : NULL;


                // Chưa hiểu tại sao nó sinh ra 3 đường dẫn với Ka, Kd, Ks
                GLuint textureID = 0;
                if (TexKa)
                {
                    textureID = TexKa->GetTextureID();
                }
                else if (TexKd)
                {
                    textureID = TexKd->GetTextureID();
                }
                else if(TexKs)
                {
                    textureID = TexKs->GetTextureID();
                }

                tagMaterialDrawInfo glMtlTemp;

                glGenVertexArrays(1, &vaoIDModel);
                glGenBuffers(1, &vboIDModel); // Generate our Vertex Buffer Object

                glMtlTemp.SetDrawType(GL_TRIANGLES);
                glMtlTemp.SetDrawSize(mesh->m_DataTrigs.size() / 3);

                glMtlTemp.SetVaoID(vaoIDModel);
                glMtlTemp.SetTextureID(textureID);
                glMtlTemp.SetMTLInfo(mtl);


                //Những thông tin liên quan thông tin về vẽ sẽ được lưu trữ trong này
                MTLInfo.push_back(glMtlTemp);


                // Thiết lập thông tin về vao ID
                glBindVertexArray(vaoIDModel);
                {
                    glBindBuffer(GL_ARRAY_BUFFER, vboIDModel);
                    glBufferData(GL_ARRAY_BUFFER, mesh->m_DataTrigs.size() * sizeof(vec3), &mesh->m_DataTrigs[0], GL_STATIC_DRAW);

                    glEnableClientState(GL_VERTEX_ARRAY);
                    glEnableClientState(GL_NORMAL_ARRAY);
                    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

                    glNormalPointer(GL_FLOAT, 3* sizeof(vec3), (void*)sizeof(vec3));
                    glVertexPointer(3, GL_FLOAT, 3* sizeof(vec3), 0);
                    glTexCoordPointer(3, GL_FLOAT, 3* sizeof(vec3), (void*)(2*sizeof(vec3)));

                    glBindBuffer(GL_ARRAY_BUFFER, 0); // Disable bind our Vertex Buffer Object
                }
                glBindVertexArray(0); // Disable our Vertex Buffer Object
            }
            // Trường hợp tiếp theo với face là một quads
            if (mesh->m_DataQuads.size() > 0)
            {
                const mtl_info* mtl = mesh->m_UseMtlInfo;

                // Load toàn bộ texture vào bộ nhớ và giữ lại dữ liệu image
                string Kaname = mtl->m_name +"_Ka";
                string Kdname = mtl->m_name +"_Kd";
                string ksname = mtl->m_name +"_Ks";

                string fka = StandardFileName(mtl->m_map_Ka);
                string fkd = StandardFileName(mtl->m_map_Kd);
                string fks = StandardFileName(mtl->m_map_Ks);

                GLTexture* TexKa = !fka.empty() ? TextureMana.CreateTexture(Kaname, pathModel + fka) : NULL;
                GLTexture* TexKd = !fkd.empty() ? TextureMana.CreateTexture(Kdname, pathModel + fkd) : NULL;
                GLTexture* TexKs = !fks.empty() ? TextureMana.CreateTexture(ksname, pathModel + fks) : NULL;


                // Chưa hiểu tại sao nó sinh ra 3 đường dẫn với Ka, Kd, Ks
                GLuint textureID = 0;
                if (TexKa)
                {
                    textureID = TexKa->GetTextureID();
                }
                else if (TexKd)
                {
                    textureID = TexKd->GetTextureID();
                }
                else if(TexKs)
                {
                    textureID = TexKs->GetTextureID();
                }

                tagMaterialDrawInfo glMtlTemp;

                glGenVertexArrays(1, &vaoIDModel);
                glGenBuffers(1, &vboIDModel); // Generate our Vertex Buffer Object

                glMtlTemp.SetDrawType(GL_QUADS);
                glMtlTemp.SetDrawSize(mesh->m_DataQuads.size() / 3);

                glMtlTemp.SetVaoID(vaoIDModel);
                glMtlTemp.SetTextureID(textureID);
                glMtlTemp.SetMTLInfo(mtl);


                //Những thông tin liên quan thông tin về vẽ sẽ được lưu trữ trong này
                MTLInfo.push_back(glMtlTemp);

                glBindVertexArray(vaoIDModel);
                {
                    glBindBuffer(GL_ARRAY_BUFFER, vboIDModel);
                    glBufferData(GL_ARRAY_BUFFER, mesh->m_DataQuads.size() * sizeof(vec3), &mesh->m_DataQuads[0], GL_STATIC_DRAW);

                    glEnableClientState(GL_VERTEX_ARRAY);
                    glEnableClientState(GL_NORMAL_ARRAY);
                    glEnableClientState(GL_TEXTURE_COORD_ARRAY);

                    glNormalPointer(GL_FLOAT, 3* sizeof(vec3), (void*)sizeof(vec3));
                    glVertexPointer(3, GL_FLOAT, 3 * sizeof(vec3), 0); 
                    glTexCoordPointer(3, GL_FLOAT, 3* sizeof(vec3), (void*)(2*sizeof(vec3)));

                    glBindBuffer(GL_ARRAY_BUFFER, 0); // Disable bind our Vertex Buffer Object
                }
                glBindVertexArray(0); // Disable our Vertex Buffer Object
            }
        }
    }
}

void OnDestroy(Window* win)
{
    delete drawDataObj;
}

void Onkeyboard(Window* win)
{
    if (win->GetKeyboardStatus(KeyA))
    {
        light_position[1] += 1.0f;
    }
    else if (win->GetKeyboardStatus(KeyD))
    {
        light_position[1] -= 1.0f;
    }

    else if (win->GetKeyboardStatus(KeyW))
    {
        light_position[2] += 1.0f;
    }
    else if (win->GetKeyboardStatus(KeyS))
    {
        light_position[2] -= 1.0f;
    }
}

void OnResize(Window* win)
{
    cam3d.SetViewSize(win->GetWidth(), win->GetHeight());
    cam3d.UpdateMatrix();
}

void OnMouseMove(Window* win)
{
    if (bRotate)
    {
        win->GetCursorPos(cur_new.x , cur_new.y);

        float delta_theta =   (cur_new.x - cur_old.x)*0.009;
        float delta_phi   =   (cur_new.y - cur_old.y)*0.009;

        cam3d.OrbitTarget(delta_phi, delta_theta);
        cam3d.UpdateMatrix();

        cur_old = cur_new;
    }
}

void OnMouseButton(Window* win)
{
    bRotate = win->GetMouseButtonStatus(GLMouse::LeftButton);
    if (bRotate)
    {
        win->GetCursorPos(cur_old.x , cur_old.y);
        vec3 cam_pos = cam3d.GetPosition();
    }
}

void OnMouseScroll(Window* win)
{
    int zDelta =  win->GetMouseScroll();
    float sensitive = 1.1f;
    cam3d.ZoomTo(zDelta* sensitive);
    cam3d.UpdateMatrix();
}
void DrawLight()
{
    glSetColor3(GL_WIH_COL);
    GLsp::DrawCube(light_position, 1.f);

    glEnable(GL_LIGHTING);
    glEnable(GL_LIGHT0);

    glEnable(GL_LIGHT1);
    glLightfv(GL_LIGHT1, GL_AMBIENT,  light_ambient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE,  light_diffuse);
    glLightfv(GL_LIGHT1, GL_SPECULAR, light_specular);
    glLightfv(GL_LIGHT1, GL_POSITION, &light_position.x);
}
void DrawGrid()
{
    //C1:Draw grid sử dụng buff là bộ nhớ cách này thỉnh thoảng chết không rõ
    //glEnableClientState(GL_VERTEX_ARRAY);
    //glEnableClientState(GL_COLOR_ARRAY);
    //glVertexPointer(3, GL_FLOAT, 2*sizeof(vec3), &grid[0]);
    //glColorPointer(3, GL_FLOAT, 2*sizeof(vec3), &grid[1]);
    //glDrawArrays(GL_LINES, 0, grid.size()/2);
    //glDisableClientState(GL_VERTEX_ARRAY);
    //glDisableClientState(GL_COLOR_ARRAY);
    //C1:Draw grid sử dụng buff là bộ nhớ trong GPU cách này cần OpenGL >1.5
    glDisable(GL_LIGHT0);
    glDisable(GL_LIGHTING);

    glBindVertexArray(vaoIDGrid);
    glDrawArrays(GL_LINES, 0, grid.size() / 2);
}

void DrawOxyz()
{
    glLineWidth(2.0);
    glBegin(GL_LINES);
    {
        glColor3f(1.0f, 0.0, 0.0);
        glVertex3f(0.001, 0.001 , 0.001);
        glVertex3f(4 , 0.001 , 0.001);

        glColor3f(0.0 , 1.0f, 0.0);
        glVertex3f(0.001, 0.001 , 0.001);
        glVertex3f(0.001 , 4 , 0.001);

        glColor3f(0.0, 0.0, 1.0);
        glVertex3f(0 , 0 , 0);
        glVertex3f(0 , 0 , 4);
    }
    glEnd();
    glLineWidth(1.0);
}

void DrawModel()
{
    //C1 : Không hiểu nhiều lúc nó bị chết sử dụng buffer trong CPU
    //glEnableClientState(GL_VERTEX_ARRAY);
    //glVertexPointer(3, GL_FLOAT, sizeof(vec3), &poly[0]);
    //glDrawArrays(GL_QUADS, 0, poly.size());

    //glDisableClientState(GL_VERTEX_ARRAY);
    //glDisableClientState(GL_COLOR_ARRAY);

    //C2 : Vẽ theo truyền thống không thấy vấn đề gì
    //glDisableClientState(GL_VERTEX_ARRAY);
    //glBegin(GL_QUADS);
    //for (int i = 0; i < poly.size(); i+=4)
    //{
    //    glVertex3f(poly[i].x, poly[i].y, poly[i].z);
    //    glVertex3f(poly[i+1].x, poly[i+1].y, poly[i+1].z);
    //    glVertex3f(poly[i+2].x, poly[i+2].y, poly[i+2].z);
    //    glVertex3f(poly[i+3].x, poly[i+3].y, poly[i+3].z);
    //}
    //glEnd();
    //glEnable(GL_LIGHT0);
    //glEnable(GL_LIGHTING);
    //glEnable(GL_COLOR_MATERIAL);
    //C3 : Vẽ model sử dụng buffer tron GPU
    //glBindVertexArray(vaoIDModelTri);
    //glDrawArrays(GL_TRIANGLES, 0, trig.size()); // Draw our triangle
    //glBindVertexArray(vaoIDModel); // Bind our Vertex Array Object
    //glDrawArrays(GL_QUADS, 0, poly.size()); // Draw our square
    //GLsp::DrawCube(vec3(0,0 ,0), 4.f);

    // Draw our triangle
    //glRotatef(90, 1.f, 0.f, 0.f);
    glScalef(0.25f, 0.25f, 0.25f);
    //glScalef(2.f, 2.f, 2.f);
    for (int i = 0; i < MTLInfo.size(); i++)
    {
        UseMTL(&MTLInfo[i]);
        glDrawArrays(MTLInfo[i].m_DrawType, 0, MTLInfo[i].m_DrawSize);
    }

    //glRotatef(-90, 1.f, 0.f, 0.f);
}

void OnProcess(Window* win)
{
    agl += 0.01f;
    vec3 pos_light_new =  M3D_CalPosition(vec3(0, 0, 0), 45.f, glm::radians(45.f), agl);
    light_position = vec4(pos_light_new, light_position.w);
}

void OnDraw(Window* win)
{
    glClearColor(0.9f, 0.9f, 0.9f, 1.0f);
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    cam3d.UseMatrix();

    DrawGrid();
    DrawLight();
    DrawOxyz();
    DrawModel();
}

int main()
{
    GLWindow window;

    WndProp adven;
    adven.m_iAntialiasing = 8;

    Window* win = new Window("Model" , 500 , 100, 900, 580);
    win->SetupAdvanced(adven);

    win->SetOnDrawfunc(OnDraw);
    win->SetOnCreatedfunc(OnCreate);
    win->SetOnDestroyfunc(OnDestroy);
    win->SetOnKeyboardfunc(Onkeyboard);
    win->SetOnMouseScrollfunc(OnMouseScroll);
    win->SetOnMouseMovefunc(OnMouseMove);
    win->SetOnResizefunc(OnResize);
    win->SetOnMouseButtonfunc(OnMouseButton);
    win->SetProcessfunc(OnProcess);

    window.AddWindow(win);

    while (window.Closed())
    {
        window.Process();
        window.Draw();
        window.PollEvent();
    }
}
